(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{385:function(a,t,s){"use strict";s.r(t);var v=s(46),n=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("看书的时候难免遇到一些问题, 在查阅清楚后在这里做一个汇总在这里做一个汇总")]),a._v(" "),s("h2",{attrs:{id:"《java核心技术-卷一》"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#《java核心技术-卷一》"}},[a._v("#")]),a._v(" 《Java核心技术 卷一》")]),a._v(" "),s("h3",{attrs:{id:"什么是码点与码元"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是码点与码元"}},[a._v("#")]),a._v(" 什么是码点与码元")]),a._v(" "),s("h4",{attrs:{id:"字符集"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符集"}},[a._v("#")]),a._v(" 字符集")]),a._v(" "),s("p",[a._v("文字与符合统称为"),s("strong",[a._v("字符")]),a._v(",所有字符的总称就是"),s("strong",[a._v("字符集")]),a._v(",常见的字符集有ASCII、Unicode、GB18030等")]),a._v(" "),s("p",[a._v("字符集一般可以由一张或者多张表组成,每张表又是以二维表的形式存储,有X和Y轴")]),a._v(" "),s("h4",{attrs:{id:"码点-code-point"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#码点-code-point"}},[a._v("#")]),a._v(" 码点(Code Point)")]),a._v(" "),s("p",[a._v("字符集中X与Y的坐标就代表一个码点,"),s("strong",[a._v("通常来讲,码点值等同于字符编码")]),a._v(",但并不是每一个码点都有与之对应的某个字符,还是存在着非字符码点和保留码点")]),a._v(" "),s("p",[a._v("以Unicode字符集为例.码点值的书写方式为"),s("strong",[a._v("U+四位十六进制数")]),a._v("或者"),s("strong",[a._v("五位十六进制数(特殊字符)")]),a._v(",例如"),s("strong",[a._v("A")]),a._v("的码点值是0041,写作"),s("strong",[a._v("U+0041")]),a._v(",😁的码点是1f601,写作"),s("strong",[a._v("U+1f601")])]),a._v(" "),s("p",[a._v("所有码点数量的总和，称之为编号空间(Code Space),随着Unicode添加的字符数越来越大,Unicode將字符按照类别分成了17个平面(Plane),每个平面存放的码点数为2^16,也就说Unicode的编码空间为为17*2^16=1114112")]),a._v(" "),s("h4",{attrs:{id:"码元-code-unit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#码元-code-unit"}},[a._v("#")]),a._v(" 码元(Code Unit)")]),a._v(" "),s("p",[a._v("码元是存储符号的最小单位,一个码点通常由一个或者多个码元来构成")]),a._v(" "),s("p",[a._v("常见的码元与其对应的常见的编码格式为")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("1字节(8个bit)             UTF-8")])]),a._v(" "),s("li",[s("p",[a._v("2字节(16个bit)           UTF-16")])]),a._v(" "),s("li",[s("p",[a._v("4字节(32个bit)           UTF-32")])])]),a._v(" "),s("p",[a._v('像"A","B","C",1,2,3以及一些常见的中文这类简单的符号,通常用一个码元就可以找到符号所对应的码点,如'),s("strong",[a._v("A")]),a._v("的码点是"),s("strong",[a._v("U+0041")]),a._v(" 码元也是"),s("strong",[a._v("U+0041")])]),a._v(" "),s("p",[a._v("而像一些特殊字符:如😁等,通常会通过一定的转换规则,將一个码点转换成两个码元,如😁的码点是"),s("strong",[a._v("U+1f601")]),a._v(",但是他的码元有两个,分别是"),s("strong",[a._v("U+d83d")]),a._v("与"),s("strong",[a._v("U+de01")])]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 通过码元反编译成字符")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"\\ud83d\\ude01"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h3",{attrs:{id:"为什么string设计成final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么string设计成final"}},[a._v("#")]),a._v(" 为什么String设计成final")]),a._v(" "),s("ol",[s("li",[s("p",[s("strong",[a._v("实现字符串池")]),a._v(",Java中充斥着大量的字符串,也就衍生出字符串池这种技术,设置成final可以保证当前字符串对象引用池中的值不会被其他对象修改")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("实现线程安全")]),a._v(",并发读是安全的,但是并发写就会出现问题,除非把他设置成不可变的")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("保证Hash唯一")]),a._v(',以HashSet举例,若HashSet存的是字符串,比如当前HashSet有两个值,分别是"value1"和"value2",HashSet只在插入的时候对值的唯一性做校验,如果此时把"value2"修改成"value1",那么HashSet就会出现两个"value1"从而导致值不唯一')])])]),a._v(" "),s("h3",{attrs:{id:"面向对象与面向过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象与面向过程"}},[a._v("#")]),a._v(" 面向对象与面向过程")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://beanchan-image.oss-cn-guangzhou.aliyuncs.com/image-20220509161627453.png",alt:"image-20220509161627453"}})]),a._v(" "),s("p",[a._v("借用书中的一张图,面向过程与面向对象本质都是操作数据")]),a._v(" "),s("p",[a._v("区别:")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("面向过程是通过各种各样的算法逻辑直接操作数据库里的数据,而面向对象是將数据库的字段封装到对象内,再基于对象来对数据进行操作")])]),a._v(" "),s("li",[s("p",[a._v("面向过程基本是针对一个需求来制定,可复用性低,但是执行效率高,而面向过程则是將程序模块化,更加符合人类的思维习惯,代码复用性高,也更易扩展")])]),a._v(" "),s("li",[s("p",[a._v("因为实现方式的不同,面向过程往往简单直接,适用于小规模问题,如门禁开关等,而面向过程比较适合复杂的程序,如Web开发")])])]),a._v(" "),s("h2",{attrs:{id:"《onjava8-基础卷》"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#《onjava8-基础卷》"}},[a._v("#")]),a._v(" 《OnJava8 基础卷》")]),a._v(" "),s("h3",{attrs:{id:"位运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[a._v("#")]),a._v(" 位运算")]),a._v(" "),s("h3",{attrs:{id:"构造器调用为什么要在最开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造器调用为什么要在最开始"}},[a._v("#")]),a._v(" 构造器调用为什么要在最开始")]),a._v(" "),s("h3",{attrs:{id:"对象不使用new生成的特殊的内存是什么内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象不使用new生成的特殊的内存是什么内存"}},[a._v("#")]),a._v(" 对象不使用new生成的特殊的内存是什么内存")]),a._v(" "),s("h3",{attrs:{id:"finalize-有什么作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#finalize-有什么作用"}},[a._v("#")]),a._v(" finalize()有什么作用")])])}),[],!1,null,null,null);t.default=n.exports}}]);