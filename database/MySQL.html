<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL | 超级开发工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/avatar.png">
    <meta name="description" content="种一棵树最好的时间是十年前,其次是现在。">
    
    <link rel="preload" href="/assets/css/0.styles.7a6eb978.css" as="style"><link rel="preload" href="/assets/js/app.c8dcfb20.js" as="script"><link rel="preload" href="/assets/js/2.b454a092.js" as="script"><link rel="preload" href="/assets/js/9.c8ce3283.js" as="script"><link rel="prefetch" href="/assets/js/10.9e5ae3e5.js"><link rel="prefetch" href="/assets/js/11.b39e5cd7.js"><link rel="prefetch" href="/assets/js/12.ba13825d.js"><link rel="prefetch" href="/assets/js/13.28c3b946.js"><link rel="prefetch" href="/assets/js/14.e8b30ec8.js"><link rel="prefetch" href="/assets/js/15.c7a6ff8b.js"><link rel="prefetch" href="/assets/js/16.f2a9d223.js"><link rel="prefetch" href="/assets/js/17.f8899822.js"><link rel="prefetch" href="/assets/js/18.203f2eef.js"><link rel="prefetch" href="/assets/js/19.b6819623.js"><link rel="prefetch" href="/assets/js/20.30c82cff.js"><link rel="prefetch" href="/assets/js/3.eba60fea.js"><link rel="prefetch" href="/assets/js/4.46286b97.js"><link rel="prefetch" href="/assets/js/5.9df3379b.js"><link rel="prefetch" href="/assets/js/6.8f3b3055.js"><link rel="prefetch" href="/assets/js/7.2efe2123.js"><link rel="prefetch" href="/assets/js/8.c0add51c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7a6eb978.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.png" alt="超级开发工程师" class="logo"> <span class="site-name can-hide">超级开发工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/Git.html" class="nav-link">
  框架
</a></li><li class="dropdown-item"><!----> <a href="/source/集合-ArrayList.html" class="nav-link">
  源码
</a></li><li class="dropdown-item"><!----> <a href="/database/MySQL.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/data_structure/数据结构-队列.html" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/miscellaneous/Java阅读问题汇总.html" class="nav-link">
  技术杂谈
</a></div><div class="nav-item"><a href="https://github.com/bean1006" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/Git.html" class="nav-link">
  框架
</a></li><li class="dropdown-item"><!----> <a href="/source/集合-ArrayList.html" class="nav-link">
  源码
</a></li><li class="dropdown-item"><!----> <a href="/database/MySQL.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/data_structure/数据结构-队列.html" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/miscellaneous/Java阅读问题汇总.html" class="nav-link">
  技术杂谈
</a></div><div class="nav-item"><a href="https://github.com/bean1006" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/database/MySQL.html" aria-current="page" class="active sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/MySQL.html#mysql" class="sidebar-link">MySQL</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_1-一条sql的一生" class="sidebar-link">1 一条SQL的一生</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/MySQL.html#_1-1-数据库查询过程" class="sidebar-link">1.1 数据库查询过程</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_1-2-select语句" class="sidebar-link">1.2 SELECT语句</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_1-3-dml语句" class="sidebar-link">1.3 DML语句</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_2-事务" class="sidebar-link">2 事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/MySQL.html#_2-1-特性-acid" class="sidebar-link">2.1 特性(ACID)</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_2-1-隔离级别" class="sidebar-link">2.1 隔离级别</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_2-2-快照在mvcc中如何工作" class="sidebar-link">2.2 快照在MVCC中如何工作</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-索引" class="sidebar-link">3 索引</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-2-类型" class="sidebar-link">3.2 类型</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-3-索引维护" class="sidebar-link">3.3 索引维护</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-4-覆盖索引" class="sidebar-link">3.4 覆盖索引</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-5-最左前缀匹配" class="sidebar-link">3.5 最左前缀匹配</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_3-6-索引下推" class="sidebar-link">3.6 索引下推</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-锁" class="sidebar-link">4 锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-1-全局锁" class="sidebar-link">4.1 全局锁</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-2-表级锁" class="sidebar-link">4.2 表级锁</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-3-行锁" class="sidebar-link">4.3 行锁</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-3-1-二阶段锁" class="sidebar-link">4.3.1 二阶段锁</a></li><li class="sidebar-sub-header"><a href="/database/MySQL.html#_4-3-2-死锁" class="sidebar-link">4.3.2 死锁</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="mysql"><a href="#mysql" class="header-anchor">#</a> MySQL</h2> <h2 id="_1-一条sql的一生"><a href="#_1-一条sql的一生" class="header-anchor">#</a> 1 一条SQL的一生</h2> <h3 id="_1-1-数据库查询过程"><a href="#_1-1-数据库查询过程" class="header-anchor">#</a> 1.1 数据库查询过程</h3> <p><img src="https://beanchan-image.oss-cn-guangzhou.aliyuncs.com/image-20220909111349004.png" alt="image-20220909111349004"></p> <p>共有三个层次 客户端、Server、引擎层</p> <ol><li><strong>客户端</strong> (DataGrip、Navicat或者Java程序等)</li> <li><strong>Service</strong> <ol><li><strong>缓存</strong>: 当一条select语句执行后,会把语句做key,值做value存在缓存中(MySQL已删除,因为太容易失效了)</li> <li><strong>分析器</strong>: 分析SQL的合法性,并将select后面的语句与字段映射,from后面的语句与表做映射</li> <li><strong>优化器</strong>: 让我(MySQL)看看哪个索引更合适</li> <li><strong>执行器</strong>: 调用指定的存储引擎</li></ol></li> <li><strong>引擎层</strong>(存储引擎,在建表时确立,MySQL5.6后默认使用InnoDB,常见的还有MySAM以及Memory等)</li></ol> <h3 id="_1-2-select语句"><a href="#_1-2-select语句" class="header-anchor">#</a> 1.2 SELECT语句</h3> <ol><li>与MySQL建立连接,并根据当前用户查询出相应的权限(权限在查出来后只要连接没中断,那就不会改变,哪怕你另起一个线程修改了,权限依然还是原来的)</li> <li>有缓存查缓存,然后返回</li> <li>做SQL校验</li> <li>让MySQL自己选择更有效的索引</li> <li>查看是否有权限,有则调用执行器查询</li></ol> <h3 id="_1-3-dml语句"><a href="#_1-3-dml语句" class="header-anchor">#</a> 1.3 DML语句</h3> <ol><li><p>与SELECT类似,先建立连接 -&gt; 查索引 -&gt; 执行</p></li> <li><p>更新数据时</p> <ol><li>redo log文件中写日志,并将状态设置为<strong>prepare</strong>,redo log位于引擎层,只有<strong>InnoDB</strong>有,用于容灾,当redo log满了后会刷到磁盘,成功后悔清除掉,所以哪怕服务器宕机,也不用担心更新数据丢失</li> <li>写完redo log后,再在bin log中记录日志,bin log位于Server层,<strong>所有引擎</strong>都可以使用,bin log的主要作用是用于备份,比如,我在主库创建数据后,可以將bin log传给从库,从库根据bin log来更新数据</li> <li>bin log 写完之后,將redo log的状态改成<strong>commit</strong>,只有状态为<strong>commit</strong>的数据,才可以刷到磁盘中,二者联动保证哪怕服务宕机或者超时,bin log和redo log仍然同步</li></ol></li></ol> <h2 id="_2-事务"><a href="#_2-事务" class="header-anchor">#</a> 2 事务</h2> <h3 id="_2-1-特性-acid"><a href="#_2-1-特性-acid" class="header-anchor">#</a> 2.1 特性(ACID)</h3> <ol><li><strong>原子性</strong>: 事务要么都成功,要么都失败</li> <li><strong>一致性</strong>: 事务前后,数据总量不变,以余额为例,转账后不管成功与否双方总额不变</li> <li><strong>隔离性</strong>: 事务之间不可互相访问,详见下一节</li> <li><strong>持久性</strong>: 事务提交后要永久保存到磁盘</li></ol> <h3 id="_2-1-隔离级别"><a href="#_2-1-隔离级别" class="header-anchor">#</a> 2.1 隔离级别</h3> <ol><li><strong>读未提交</strong>: 可以读取到其他事务已更新但是未提交的数据(脏读)</li> <li><strong>读已提交</strong>: 可以读取到其他事务已提交的数据,但是本身事务中多次查询同一个SQL可能获取不同的结果(不可重复读)</li> <li><strong>可重复读</strong>: 一个事务中,查询同一条SQL两次,结果一致,但如果有更新操作可能会有新的行没被更新到或者少了几行(幻读)</li> <li><strong>串行化</strong>: 直接上锁,只有当前事务可以访问</li></ol> <h3 id="_2-2-快照在mvcc中如何工作"><a href="#_2-2-快照在mvcc中如何工作" class="header-anchor">#</a> 2.2 快照在MVCC中如何工作</h3> <p>​	在MySQL中,解决脏读和不可重复读的主要方式就是<strong>多版本并发控制-MVCC</strong>(Multi Version Concurrency Control)</p> <p>​	实现的方式是:在事务开始时创建一个快照视图,事务只能访问数据视图内的数据,进而保证数据的可重复读,一般使用场景为数据库备份</p> <p>​	实现原理如下:</p> <p>​	首先数据库中的每行数据除了业务数据以外,还包含两个隐藏字段: <strong>row_trx_id</strong>(哪个事务更新本行数据),<strong>roll_pointer</strong>(上一个版本的undo log)</p> <p>​	这里出现了一个undo log的概念,前文<strong>1.3</strong>中有介绍两个东西bin log(复制、数据备份时使用)以及redo log(灾后数据恢复),而新出现的undo log则是指,每当有新的事务提交后,就会有一个新版本数据,并将这个版本的roll_pointer指向上一个版本数据,从而形成一条<strong>undo log链</strong>,当需要回滚的时候则通过roll_pointer找到上一个版本</p> <p>​	除了undo log还需要展开介绍一下视图,视图是在事务开始时(手动开),或者事务第一次执行CRUD语句时建立,每个视图都包含四个字段</p> <div class="language- extra-class"><pre><code>1. creator_trx_id: 本次事务的id(事务id是从小到大递增的)
1. m_ids: 目前已经创建但是还没commit的事务id数组
1. min_trx_id: 第一条还没commit的事务中
1. max_trx_id: 所有事务中(不管是否commit)最后一次创建的事务+1,即:下一条将要创建的事务id
</code></pre></div><p>通过undo log以及视图,就可以实现事务读取到他该读的数据</p> <p>举个例子:</p> <p>当一条update语句更新一行的时候,他会遇到这几种情况:</p> <ol><li>row_trx_id是否小于min_trx_id,是则说明修改这条数据的事务已经提交了,这行数据<strong>可以读取</strong></li> <li>row_trx_id是否大于max_trx_id,是则说明修改这条数据在创建视图之后还有其他事务也更新了,他已经不是最新的了,<strong>不可读取</strong></li> <li>如果row_trx_id在min_trx_id和max_trx_id之间,则需要分情况讨论
<ol><li>row_trx_id = creator_trx_id,自己修改的当然<strong>可以读取</strong></li> <li>row_trx_id != creator_trx_id
<ol><li>row_trx_id在m_ids里,当前事务和row_trx_id的事务并发修改了这一行,<strong>不可读取</strong></li> <li>row_trx_id不在m_ids里,说明row_trx_id已经提交过了,则这行就是最新的了,<strong>可以读取</strong></li></ol></li></ol></li></ol> <p>如果发现不可取,那他就会通过roll_pointer找到上一个版本,再通过上面的方式判断,直至找到可以读取为止</p> <h3 id="_3-索引"><a href="#_3-索引" class="header-anchor">#</a> 3 索引</h3> <h4 id="_3-1-数据结构"><a href="#_3-1-数据结构" class="header-anchor">#</a> 3.1 数据结构</h4> <p>三类:</p> <ol><li><p>hash</p> <p>实现方式: 参考HashMap</p> <p>优点: 新增快,单个查询快</p> <p>缺点:范围查找慢</p> <p>适用范围: 单个查找的缓存</p></li> <li><p>有序数组</p> <p>实现方式: 递增数组</p> <p>优点:单个查找和范围查找都快(二分搜索)</p> <p>缺点: 新增慢,需要移动后面的数组</p> <p>使用返回: 静态存储不会修改的数据,例如,某一年的数据</p></li> <li><p>tree</p></li></ol> <p>实现方式: 二叉树: 大小关系为 左 &lt; 父 &lt; 右 (效率高但用得少,树高太高的话请求数据块次数太多)</p> <p>​				 多叉树: 子树从左往右递增</p> <p>优点: 查询与插入都是O(LogN)</p> <p>缺点: 查单个的时候比hash慢(总得有点缺点)</p> <p>适用范围: 上面做不到的树都能做到,就是做不到第一</p> <h3 id="_3-2-类型"><a href="#_3-2-类型" class="header-anchor">#</a> 3.2 类型</h3> <ol><li><strong>主键索引</strong> : 主键自动成索引,不可重复</li> <li><strong>普通索引</strong>: 可以重复的索引</li> <li><strong>唯一索引</strong>: 不可重复的索引</li> <li><strong>复合索引</strong>: 可以理解为把多个普通索引合并成一个索引</li></ol> <p>聚簇(cù)索引或者一级索引(主键索引): 叶子节点存值</p> <p>非聚簇索引或者二级索引(其他三个): 叶子存主键</p> <p>查非聚簇索引时,因为只能查到主键,索引需要回表二次查</p> <h3 id="_3-3-索引维护"><a href="#_3-3-索引维护" class="header-anchor">#</a> 3.3 索引维护</h3> <p><strong>非主键索引</strong>或者<strong>主键索引但是主键非自增</strong>,在插入元素时</p> <p>​	如果正好新元素需要插在一个叶子数据块的中间,则意味着插入位置后面的元素都需要往后移动一个,因为树结构采用页式存储,每个叶子节点都是一个页,如果大于数据库存储数量,则会触发<strong>页分裂</strong>,影响性能,影响原因如下 (ps: 如果两个页的利用率都太低,则会页聚合)</p> <ol><li>会将一部分数据移动到下一个页</li> <li>分页后也会导致空间利用率变低,降低50%</li></ol> <p><strong>主键索引</strong>并且主键自增,在插入元素时(<strong>尽可能使用自增索引</strong>)</p> <p>​	每条数据都是顺序插入,不会引起页分裂</p> <h3 id="_3-4-覆盖索引"><a href="#_3-4-覆盖索引" class="header-anchor">#</a> 3.4 覆盖索引</h3> <p>​	<strong>3.2</strong>的时候交代:使用非主键索引来进行查找的时候,通常都会回表,从而变成查了两次,那么看以下的情况:</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&quot;Woohoo&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这种情况下,第一次会查出name为Woohoo的行的主键,因为第一次走的是非聚簇索引,所以只能查出主键,但是主键就是我们需要的东西,所以不必回表查了,这就被称为<strong>覆盖索引</strong>,是一种非常常用的优化手段</p> <p>​	<strong>那么有必要创建身份证号_姓名这样的复合索引吗?身份证加上姓名是唯一的,但是身份证号本就是唯一的,所以这个复合索引就没意义吗?</strong></p> <p>​	如果说此时有一个需求,会大量通过身份证查姓名</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> name <span class="token keyword">from</span> <span class="token keyword">user</span> idNumber <span class="token operator">=</span> <span class="token string">&quot;350101199710062666&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那这个复合索引就是有意义的,出于<strong>索引覆盖</strong>的原因只需要查一次复合索引即可,无需要再回表查,会省出大量时间</p> <h3 id="_3-5-最左前缀匹配"><a href="#_3-5-最左前缀匹配" class="header-anchor">#</a> 3.5 最左前缀匹配</h3> <p>​	<strong>如果有一张表user里面有四个字段 id, 身份证号码,姓名,手机号,有一个接口需要查询姓名,另一个接口需要查手机号,如何构建索引效率最高?</strong></p> <p>​	可以构建一个复合索引(姓名,手机号),那么当查询条件只有姓名或者查询条件是姓名+索引时,便会走这个索引,其中必须满足以下几点:</p> <ol><li>最左边的如果是字符串,可以模糊查询但必须右模糊,并且后续的都不生效,例如: (name = &quot;陈%&quot; and phone = 110,则只有<strong>name = &quot;陈%&quot;</strong>,可以生效</li> <li>最左边如果是数字,若是范围查询,则只有最左边的索引生效,后续的都不生效</li> <li>如果我们有一个接口查姓名,另一个接口查手机号,那么在只查手机号的时候,(姓名,手机号)这个索引就生效了,所以必须再维护一个普通索引或者唯一索引(手机号)</li></ol> <h3 id="_3-6-索引下推"><a href="#_3-6-索引下推" class="header-anchor">#</a> 3.6 索引下推</h3> <p>​	还是这么一个表user,字段如下: id,身份证号码,姓名,手机号</p> <p>​	构建一个复合索引(姓名,手机号),那么当执行以下语句时,</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&quot;陈%&quot;</span> <span class="token operator">and</span> phone <span class="token operator">=</span> <span class="token string">&quot;110&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	因为使用了模糊查询,所以索引只能走到name,但是后面的phone就直接废除了吗?</p> <p>​	曾今是的,但在mysql5.6之后多了个索引下推的功能,他会去排除phone!=&quot;110&quot;的数据,从而减少回表次数</p> <h2 id="_4-锁"><a href="#_4-锁" class="header-anchor">#</a> 4 锁</h2> <h3 id="_4-1-全局锁"><a href="#_4-1-全局锁" class="header-anchor">#</a> 4.1 全局锁</h3> <p>当表开启全局锁的时候,其他线程的所有DDL或者DML语句都将被暂停</p> <p>使用场景:全库逻辑备份(但是支持 mvcc 的可以不需要)</p> <h3 id="_4-2-表级锁"><a href="#_4-2-表级锁" class="header-anchor">#</a> 4.2 表级锁</h3> <ol><li><p><strong>表锁</strong> 直接锁定整张表(手动上锁)</p> <ol><li>上读锁,则其他线程和自身都不可以写数据,但可以读数据;</li> <li>上写锁,则只允许当前线程自身读写数据</li></ol></li> <li><p><strong>元数据锁-MDL(metaData Lock)</strong> 防止 DDL 与 DML 之间以及 DDL 与 DDL 之间的并发冲突(系统自动上锁)</p> <ol><li>上读锁,保证表结构不能变,其他线程和自身都可以CRUD</li> <li>上写锁,只有自身线程可以对表结构进行改变,并且其他线程不可进行CRUD与增删字段</li> <li>在事务中,事务一开启就会获取MDL,并且写锁优先级会高于读锁优先级,如果最开始先获取了读锁,后续一个线程请求写锁,一个线程请求读锁,则写锁会先被阻塞,因为写锁优先级高,所以读锁也会被堵塞,如果客户端还有重试机制,那整个库的线程就爆满了,因此一定要<strong>避免长事务</strong></li></ol> <p>DDL操作可能会引起线上CRUD阻塞,因此需要谨慎</p></li></ol> <h3 id="_4-3-行锁"><a href="#_4-3-行锁" class="header-anchor">#</a> 4.3 行锁</h3> <p>首先,行锁只有InnoDB存储引擎支持</p> <h3 id="_4-3-1-二阶段锁"><a href="#_4-3-1-二阶段锁" class="header-anchor">#</a> 4.3.1 二阶段锁</h3> <p>事务当中</p> <p>第一阶段是上锁: 第一次执行update语句时,会对更新的所有行加上行锁</p> <p>第二阶段是解锁: 只有在事务提交之后,才会将锁释放</p> <p>所以应该尽可能把并发度高的更新语句放在事物的最末端,减小锁被占用的时间,进而减小冲突的可能</p> <h3 id="_4-3-2-死锁"><a href="#_4-3-2-死锁" class="header-anchor">#</a> 4.3.2 死锁</h3> <p>现在有以下情况:</p> <ol><li><p>事务A执行一个update语句锁定了行A(没来得及commit)</p></li> <li><p>事务B执行一个update语句,锁定了行B</p></li> <li><p>此时若事务A需要操作行B并且事务B需要操作行A</p></li></ol> <p>因为事务中只要执行了update语句就会上锁,所以这个时候事务A和事务B都在等待对方释放锁,这也就是<strong>死锁</strong></p> <p>解决死锁有两个有两种策略:</p> <ol><li><p><strong>超时回滚</strong>,当线程等待超时(MySQL默认等待时间是50s),则会回滚当前事务</p> <p>如果死锁则需要等待50s,这队系统来说是致命的,但是</p></li> <li><p><strong>死锁检测</strong>,每当获取一个锁的时候会被加到所队列,然后判断自己的加入是否会引起死锁,会则回滚自身业务,但是因为检测需要消耗资源,若并发量很大,则很容易导致CPU满负载,因此会看到CPU利用率很高,但是没处理几个事务</p></li></ol> <p><strong>如何解决高访问率的行数据?</strong></p> <ol><li><p><strong>关闭死锁检测</strong>,确保事务不会发生死锁,可以关闭死锁检测,缺点就是,万一发生死锁,挺50s对系统十分致命</p></li> <li><p><strong>并发控制</strong>,对数据库并发量进行控制</p> <ol><li>客户端层面做并发控制,但是客户端多了请求数据库压力依然很大</li> <li>中间件做并发控制</li> <li>MySQL源码层面做并发控制</li> <li>拆行,例如有一个账户是热点行,可以把一个账户拆成N个行,增减余额时候随机取一个处理出来</li></ol></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c8dcfb20.js" defer></script><script src="/assets/js/2.b454a092.js" defer></script><script src="/assets/js/9.c8ce3283.js" defer></script>
  </body>
</html>
